<!DOCTYPE html>
<html lang="es">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1, viewport-fit=cover" />
  <title>Reloj</title>
  <!-- TipografÃ­a estilo reloj digital (fallback a monospace) -->
  <link href="https://fonts.cdnfonts.com/css/ds-digital" rel="stylesheet">
  <style>
    /* ==========================================================
       THEME / TOKENS
       ========================================================== */
    :root {
      --bg: #000;                         /* fondo absoluto */
      --fg: #fff;                         /* texto principal */
      --glow: rgba(255,255,255,.08);      /* halo sutil del dÃ­gito */

      /* Controles */
      --btn-bg: rgba(255,255,255,.06);
      --btn-border: rgba(255,255,255,.18);
      --btn-active: rgba(255,255,255,.25);

      /* Segundero circular */
      --ring-track: rgba(255,255,255,.10);        /* carril base */
      --ring-progress: rgba(255,255,255,.85);     /* progreso casi blanco */
      --tick: rgba(255,255,255,.22);              /* marcas no transitadas */
      --tick-elapsed: rgba(255,255,255,.75);      /* marcas transitadas */
      --ring-size: min(86vmin, 88vmin);           /* diÃ¡metro del aro */
    }

    /* ==========================================================
       LAYOUT BASE
       ========================================================== */
    html, body {
      height: 100%;
      margin: 0;
      background: var(--bg);
      color: var(--fg);
      overflow: hidden;                 /* sin scroll */
      user-select: none;                /* no seleccionable */
      -webkit-tap-highlight-color: transparent;
    }
    .wrap { position: fixed; inset: 0; display: grid; place-items: center; }

    /* ==========================================================
       RELOJ (HH:MM) â€” CENTRADO Y ESTABLE
       ========================================================== */
    .clock-box { position: relative; display: grid; place-items: center; }
    #clock {
      font-family: 'DS-Digital','DS-Digital Bold',ui-monospace,SFMono-Regular,Menlo,Monaco,Consolas,'Liberation Mono','Courier New',monospace;
      font-weight: 700;
      line-height: 1;
      font-variant-numeric: tabular-nums;
      letter-spacing: .04em;
      white-space: nowrap;
      text-shadow: 0 0 .035em var(--glow), 0 0 .1em var(--glow);
      font-size: min(28vw, 28vh);       /* responsivo al viewport */
      -webkit-font-smoothing: antialiased;
      text-rendering: optimizeLegibility;
      position: relative;
      z-index: 2;
      text-align: center;
    }
    /* Reserva de ancho mÃ¡ximo para evitar saltos visuales */
    .clock-box::before{
      content: '88:88';
      font-family: 'DS-Digital','DS-Digital Bold',ui-monospace,SFMono-Regular,Menlo,Monaco,Consolas,'Liberation Mono','Courier New',monospace;
      font-weight: 700;
      line-height: 1;
      letter-spacing: .04em;
      white-space: nowrap;
      font-size: min(28vw, 28vh);
      position: absolute; left: 50%; top: 50%; transform: translate(-50%,-50%);
      visibility: hidden; pointer-events: none; user-select: none;
    }

    /* ==========================================================
       SEGUNDERO CIRCULAR (SVG)
       ========================================================== */
    .sec-ring { position: absolute; width: var(--ring-size); height: var(--ring-size); z-index: 1; pointer-events: none; opacity: .9; }
    .sec-ring.hidden { display: none; }
    .sec-ring circle { fill: none; }
    .sec-ring line { stroke: var(--tick); stroke-linecap: round; }
    .sec-ring line.elapsed { stroke: var(--tick-elapsed); }
    .sec-ring line.active { stroke: var(--ring-progress); stroke-width: .9; }

    /* Segundos mini bajo HH:MM (sin interferir con centrado) */
    #miniSec {
      position: absolute; left: 50%; top: 50%; transform: translate(-50%, calc(-50% + 2.4em));
      font-family: 'DS-Digital','DS-Digital Bold',ui-monospace,SFMono-Regular,Menlo,Monaco,Consolas,'Liberation Mono','Courier New',monospace;
      font-weight: 700; line-height: 1; letter-spacing: .04em; white-space: nowrap;
      font-size: min(6vw, 6vh);
      color: var(--fg); opacity: .9;
      text-shadow: 0 0 .03em var(--glow), 0 0 .08em var(--glow);
    }
    #miniSec.hidden { display: none; }

    /* ==========================================================
       CONTROLES (AUTO-HIDE + ANIMACIÃ“N)
       ========================================================== */
    .controls {
      position: fixed; left: 50%; bottom: 2.2vh; transform: translateX(-50%);
      display: flex; gap: .6rem; align-items: center; justify-content: center;
      opacity: .8; will-change: opacity, transform;
      transition: opacity .45s cubic-bezier(.22,.61,.36,1), transform .45s cubic-bezier(.22,.61,.36,1);
    }
    .controls.hidden { opacity: 0; transform: translate(-50%, 12px) scale(.98); pointer-events: none; }
    .controls button {
      width: 36px; height: 36px; display: grid; place-items: center;
      border-radius: 999px; background: var(--btn-bg); color: var(--fg);
      border: 1px solid var(--btn-border); backdrop-filter: blur(2px);
      cursor: pointer; transition: background .15s ease, border-color .15s ease, opacity .2s ease;
    }
    .controls button:hover { opacity: 1; }
    .controls button.active { background: var(--btn-active); border-color: var(--fg); }
    .controls svg { width: 18px; height: 18px; fill: currentColor; }
    .controls, .controls * { cursor: pointer; }
    body.hide-cursor { cursor: none; }

    @media print { .controls { display: none; } }
    .toast { position: fixed; left: 50%; bottom: calc(2.2vh + 56px); transform: translateX(-50%); background: rgba(255,255,255,.08); color: var(--fg); border: 1px solid rgba(255,255,255,.18); border-radius: 999px; padding: .4rem .8rem; font-size: 13px; line-height: 1; opacity: .95; backdrop-filter: blur(2px); transition: opacity .35s ease, transform .35s ease; display: flex; align-items: center; gap: .4rem; }
    .toast.hidden { opacity: 0; transform: translate(-50%, 2px) scale(.99); pointer-events: none; }

  </style>
</head>
<body>
  <div class="wrap" aria-hidden="true">
    <div class="clock-box" id="clockBox">
      <!-- Segundero circular detrÃ¡s (track + progreso + ticks) -->
      <svg class="sec-ring" id="secRing" viewBox="0 0 100 100" aria-hidden="true">
        <g id="ticks"></g>
        <circle class="track" id="secTrack" cx="50" cy="50" r="45" />
        <circle class="progress" id="secProg" cx="50" cy="50" r="45" />
      </svg>

      <!-- Hora principal -->
      <div id="clock">00:00</div>
      <!-- Segundos mini (se ocultan cuando se oculta el segundero) -->
      <div id="miniSec" aria-hidden="true">:00</div>
    </div>
  </div>

  <!-- Controles compactos (teclas: F pantalla completa, S segundero, P 12/24h, M sonido) -->
  <div class="controls" role="group" aria-label="Ajustes del reloj">
    <button id="toggle-seconds" aria-pressed="true" class="active" title="Mostrar / ocultar segundero circular" aria-label="Mostrar / ocultar segundero circular">
      <!-- Aro con arco y marcas cardinales -->
      <svg viewBox="0 0 24 24" aria-hidden="true">
        <circle cx="12" cy="12" r="9" fill="none" stroke="currentColor" stroke-width="1" opacity="0.6"/>
        <path d="M12 3 A9 9 0 0 1 20 9" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"/>
        <line x1="12" y1="3" x2="12" y2="5" stroke="currentColor" stroke-width="1"/>
        <line x1="21" y1="12" x2="19" y2="12" stroke="currentColor" stroke-width="1"/>
        <line x1="3" y1="12" x2="5" y2="12" stroke="currentColor" stroke-width="1"/>
        <line x1="12" y1="21" x2="12" y2="19" stroke="currentColor" stroke-width="1"/>
      </svg>
    </button>

    <button id="toggle-sound" aria-pressed="false" title="Activar / desactivar sonido" aria-label="Activar / desactivar sonido">
      <!-- Icono: altavoz con ondas -->
      <svg viewBox="0 0 24 24" aria-hidden="true">
        <path d="M4 9v6h4l5 4V5L8 9H4z" fill="currentColor" opacity="0.85"/>
        <path d="M15 9a3 3 0 0 1 0 6" fill="none" stroke="currentColor" stroke-width="1.5" stroke-linecap="round"/>
        <path d="M17 7a6 6 0 0 1 0 10" fill="none" stroke="currentColor" stroke-width="1.5" stroke-linecap="round" opacity="0.7"/>
      </svg>
    </button>

    <button id="toggle-ampm" aria-pressed="false" title="Alternar 24h / 12h" aria-label="Alternar 24h / 12h">
      <!-- 12/24 dentro de un cÃ­rculo -->
      <svg viewBox="0 0 24 24" aria-hidden="true">
        <circle cx="12" cy="12" r="10" fill="none" stroke="currentColor" stroke-width="1.5"/>
        <text x="12" y="9" text-anchor="middle" font-size="6" font-family="ui-monospace, monospace">12</text>
        <text x="12" y="17" text-anchor="middle" font-size="6" font-family="ui-monospace, monospace">24</text>
      </svg>
    </button>
  </div>

  <!-- Aviso discreto para habilitar audio si el navegador lo bloquea -->
  <div id="audioHint" class="toast hidden" role="status" aria-live="polite">
    <span aria-hidden="true">ðŸ”ˆ</span>
    <span>Para habilitar sonido, toca la pantalla o presiona <strong>M</strong>.</span>
  </div>

  <script>
    'use strict';
    /* ==========================================================
       ESTADO / REFERENCIAS DOM
       ========================================================== */
    let use24h = false;      // false => 12h (sin sufijo)
    let showSeconds = true;  // controla anillo + segundos mini
    let soundOn = false;     // sonido de tick/minuto

    const $clock     = document.getElementById('clock');
    const $btnAmPm   = document.getElementById('toggle-ampm');
    const $btnSec    = document.getElementById('toggle-seconds');
    const $btnSound  = document.getElementById('toggle-sound');
    const $ring      = document.getElementById('secRing');
    const $ticks     = document.getElementById('ticks');
    const $prog      = document.getElementById('secProg');
    const $miniSec   = document.getElementById('miniSec');
    const $controls  = document.querySelector('.controls');
    const $audioHint = document.getElementById('audioHint');

    const STORE_KEY = 'robert-clock:v1';          // clave de persistencia
    const R = 45;                                  // radio geomÃ©trico del aro (uu del viewBox)
    const STROKE_UU = 1.2;                         // grosor del trazo en uu del viewBox
    const C = 2 * Math.PI * R;                     // longitud de la circunferencia
    const HIDE_AFTER = 1000;                       // ms sin interacciÃ³n para ocultar controles/cursor

    /* ==========================================================
       UTILIDADES
       ========================================================== */
    const pad = n => n.toString().padStart(2,'0');
    const isFullscreen = () => document.fullscreenElement || document.webkitFullscreenElement || document.msFullscreenElement;
    const toggleFullscreen = () => {
      const docEl = document.documentElement;
      if (!isFullscreen()) (docEl.requestFullscreen||docEl.webkitRequestFullscreen||docEl.msRequestFullscreen).call(docEl);
      else (document.exitFullscreen||document.webkitExitFullscreen||document.msExitFullscreen).call(document);
    };

    /* ==========================================================
       AUDIO (Web Audio) â€” tick analÃ³gico y campanita de minuto
       ========================================================== */
    let audioCtx = null;
    let masterOut = null;
    const MASTER_GAIN = 1.6; // volumen global (sube/baja todo el sistema de audio)

    function ensureAudio(){
      try {
        const AC = window.AudioContext || window.webkitAudioContext;
        if (!AC) return false;
        if (!audioCtx) audioCtx = new AC();
        else if (audioCtx.state === 'suspended') audioCtx.resume();
        if (audioCtx && !masterOut){
          masterOut = audioCtx.createGain();
          masterOut.gain.setValueAtTime(MASTER_GAIN, audioCtx.currentTime);
          masterOut.connect(audioCtx.destination);
        }
        return !!(audioCtx && audioCtx.state !== 'closed');
      } catch(_){ return false; }
    }

    // Tick analÃ³gico: ruido band-pass + tono corto, cÃ³modo y hogareÃ±o
    function playTick(){
      if (!audioCtx || !masterOut) return;
      const ctx = audioCtx; const t = ctx.currentTime;
      // Ruido (click mecÃ¡nico)
      const dur = 0.08;
      const buf = ctx.createBuffer(1, Math.ceil(ctx.sampleRate * dur), ctx.sampleRate);
      const data = buf.getChannelData(0);
      for (let i = 0; i < data.length; i++) data[i] = (Math.random()*2-1) * (1 - i/data.length);
      const noise = ctx.createBufferSource(); noise.buffer = buf;
      const bp = ctx.createBiquadFilter(); bp.type = 'bandpass'; bp.frequency.value = 2200; bp.Q.value = 5;
      const g = ctx.createGain();
      const peak = 0.085; // â†‘ un poco el volumen del tick (sin cambiar tono)
      g.gain.setValueAtTime(0, t);
      g.gain.linearRampToValueAtTime(peak, t + 0.002);
      g.gain.exponentialRampToValueAtTime(0.0001, t + 0.06);
      noise.connect(bp); bp.connect(g); g.connect(masterOut);
      noise.start(t); noise.stop(t + dur);
      // Tono corto de cuerpo
      const osc = ctx.createOscillator(); osc.type = 'triangle'; osc.frequency.setValueAtTime(1050, t);
      const g2 = ctx.createGain(); g2.gain.setValueAtTime(0.055, t); g2.gain.exponentialRampToValueAtTime(0.0001, t + 0.05);
      osc.connect(g2); g2.connect(masterOut); osc.start(t); osc.stop(t + 0.06);
    }

    // Campanita dulce para el minuto: parciales + cola suave (timbre)
    function playChimeMinute(){
      if (!audioCtx || !masterOut) return;
      const ctx = audioCtx; const t = ctx.currentTime;
      // Mezcla principal con envolvente mÃ¡s larga pero algo mÃ¡s contenida
      const master = ctx.createGain();
      master.gain.setValueAtTime(0, t);
      master.gain.linearRampToValueAtTime(0.14, t + 0.006); // volumen mÃ¡s balanceado
      master.gain.exponentialRampToValueAtTime(0.0001, t + 0.7);
      master.connect(masterOut);

      // Parciales de campanita (un solo toque dulce)
      const base = 1500;
      const parts = [
        { f: base*1.00, g: 0.95, d: 0.60 },
        { f: base*1.35, g: 0.55, d: 0.52 },
        { f: base*2.10, g: 0.35, d: 0.46 },
        { f: base*2.90, g: 0.22, d: 0.40 }
      ];
      parts.forEach(p => {
        const o = ctx.createOscillator(); o.type = 'sine';
        const g = ctx.createGain();
        o.frequency.setValueAtTime(p.f, t);
        g.gain.setValueAtTime(p.g, t);
        g.gain.exponentialRampToValueAtTime(0.0001, t + p.d);
        o.connect(g); g.connect(master);
        o.start(t); o.stop(t + p.d + 0.02);
      });

      // Ataque sutil tipo macito (breve, dulce)
      const atk = ctx.createOscillator(); atk.type = 'triangle'; atk.frequency.setValueAtTime(base*1.7, t);
      const atkG = ctx.createGain(); atkG.gain.setValueAtTime(0.045, t); atkG.gain.exponentialRampToValueAtTime(0.0001, t + 0.05);
      atk.connect(atkG); atkG.connect(master); atk.start(t); atk.stop(t + 0.06);

      // Cola/eco muy corto (un solo tap) para sensaciÃ³n de difuminado
      const d = ctx.createDelay(0.5); d.delayTime.setValueAtTime(0.12, t);
      const fb = ctx.createGain(); fb.gain.setValueAtTime(0.10, t);
      master.connect(d); d.connect(fb); fb.connect(d); d.connect(masterOut);
    }

    let lastBeepAt = 0;
    function tickSecond(){
      const now = performance.now();
      if (now - lastBeepAt < 280) return; // evita dobles disparos al cambiar visibilidad
      lastBeepAt = now;
      playTick();
    }
    function tickMinute(){
      const now = performance.now();
      if (now - lastBeepAt < 280) return; // evita dobles disparos
      lastBeepAt = now;
      playChimeMinute();
    }

    /* ==========================================================
       RENDER PRINCIPAL (HH:MM) â€” repinta solo al cambiar de minuto
       ========================================================== */
    function drawTime(){
      const now = new Date();
      let h = now.getHours();
      if (!use24h) h = (h % 12) || 12;          // 12h sin sufijo
      const m = now.getMinutes();
      $clock.textContent = `${pad(h)}:${pad(m)}`;
    }

    /* ==========================================================
       SEGUNDERO CIRCULAR â€” progreso continuo + realce del tick actual
       ========================================================== */
    // preparar arco: dasharray y grosor en unidades del viewBox para alinear perfecto
    (function prepRing(){
      document.getElementById('secTrack').setAttribute('stroke-width', STROKE_UU);
      $prog.setAttribute('stroke-width', STROKE_UU);
      $prog.setAttribute('stroke-dasharray', C.toFixed(3));
    })();

    // crear 60 marcas con 12 mÃ¡s largas (cada 5 s), alineadas -90Â° (arriba)
    (function buildTicks(){
      const center = 50, rLineEnd = R, long = 4.4, short = 2.2;
      window.__tickEls = [];
      for (let i = 0; i < 60; i++) {
        const a = (i/60)*2*Math.PI - Math.PI/2;        // radianes, origen arriba
        const len = (i % 5 === 0) ? long : short;      // marca larga cada 5 s
        const r1 = rLineEnd - len;                     // punto interior
        const x1 = center + r1 * Math.cos(a);
        const y1 = center + r1 * Math.sin(a);
        const x2 = center + rLineEnd * Math.cos(a);
        const y2 = center + rLineEnd * Math.sin(a);
        const line = document.createElementNS('http://www.w3.org/2000/svg','line');
        line.setAttribute('x1', x1.toFixed(3));
        line.setAttribute('y1', y1.toFixed(3));
        line.setAttribute('x2', x2.toFixed(3));
        line.setAttribute('y2', y2.toFixed(3));
        line.setAttribute('stroke-width', (i % 5 === 0) ? '0.9' : '0.6');
        $ticks.appendChild(line);
        __tickEls.push(line);
      }
    })();

    let lastSecond = -1, lastMinute = -1;
    // Sincroniza anillo y marcas con el tiempo real (Ãºtil al volver de pestaÃ±a oculta)
    function syncSecondsVisualNow(){
      const now = new Date();
      const progress = (now.getSeconds()*1000 + now.getMilliseconds()) / 60000; // 0..1
      const sec = now.getSeconds();
      // actualizar arco
      const offset = C * (1 - progress);
      $prog.setAttribute('stroke-dashoffset', offset.toFixed(3));
      // limpiar y marcar acumulado correcto
      for (let i = 0; i < 60; i++) __tickEls[i].classList.remove('elapsed','active');
      for (let i = 0; i <= sec; i++) __tickEls[i].classList.add('elapsed');
      __tickEls[sec].classList.add('active');
      lastSecond = sec;
      lastMinute = now.getMinutes();
      if (showSeconds) $miniSec.textContent = ':' + pad(sec);
    }
    function drawSeconds(progress){
      if ($ring.classList.contains('hidden')) return;
      const offset = C * (1 - progress);
      $prog.setAttribute('stroke-dashoffset', offset.toFixed(3));
      const sec = Math.floor(progress * 60) % 60; // segundo actual 0..59
      if (sec !== lastSecond) {
        // reset de minuto: limpiar todas las marcas al llegar a 0
        if (sec === 0) {
          for (let i = 0; i < 60; i++) { __tickEls[i].classList.remove('elapsed','active'); }
        }
        // acumular: marcar como 'elapsed' todas las marcas hasta el segundo actual (incluida)
        for (let i = 0; i <= sec; i++) { __tickEls[i].classList.add('elapsed'); }
        // mover resaltado del segundo activo
        if (lastSecond >= 0) __tickEls[lastSecond].classList.remove('active');
        __tickEls[sec].classList.add('active');
        lastSecond = sec;
        // Sonido
        if (soundOn && audioCtx) { if (sec === 0) tickMinute(); else tickSecond(); }
      }
    }

    // bucle 60 fps: mueve progreso continuo; repinta HH:MM solo al cambiar de minuto
    function loop(){
      const now = new Date();
      const progress = (now.getSeconds()*1000 + now.getMilliseconds()) / 60000; // 0..1
      drawSeconds(progress);
      if (showSeconds) $miniSec.textContent = ':' + pad(now.getSeconds());
      if (now.getMinutes() !== lastMinute) { lastMinute = now.getMinutes(); drawTime(); }
      requestAnimationFrame(loop);
    }

    /* ==========================================================
      CONTROLES / PREFERENCIAS / WAKE LOCK
      ========================================================== */
    function updateButtons(){
      $btnAmPm.classList.toggle('active', !use24h);
      $btnAmPm.setAttribute('aria-pressed', String(!use24h));

      $btnSec.classList.toggle('active', showSeconds);
      $btnSec.setAttribute('aria-pressed', String(showSeconds));
      $ring.classList.toggle('hidden', !showSeconds);
      $miniSec.classList.toggle('hidden', !showSeconds);

      $btnSound.classList.toggle('active', soundOn);
      $btnSound.setAttribute('aria-pressed', String(soundOn));
    }

    // Persistencia
    function savePrefs(){
      try {
        localStorage.setItem(STORE_KEY, JSON.stringify({ use24h, showSeconds, soundOn }));
      } catch(_){/* noop */}
    }
    function loadPrefs(){
      try {
        const v = JSON.parse(localStorage.getItem(STORE_KEY));
        if (v) {
          use24h = !!v.use24h;
          showSeconds = !!v.showSeconds;
          soundOn = !!v.soundOn;
        }
      } catch(_){/* noop */}
    }

    // Wake Lock (evita suspensiÃ³n de pantalla)
    let wakeLock = null;
    async function requestWakeLock(){
      try {
        if ('wakeLock' in navigator) {
          if (wakeLock) { await wakeLock.release().catch(()=>{}); wakeLock = null; }
          wakeLock = await navigator.wakeLock.request('screen');
          wakeLock.addEventListener('release', () => {});
        }
      } catch(_){ /* noop */ }
    }

    // Ticker en segundo plano (para que suene aunque la pestaÃ±a no estÃ© al frente)
    let bgTimer = null, lastSecondEmit = -1;
    function startBgTicker(){
      if (bgTimer) return;
      bgTimer = setInterval(()=>{
        const now = new Date();
        const s = now.getSeconds();
        if (s !== lastSecondEmit) {
          if (soundOn && audioCtx) { if (s === 0) tickMinute(); else tickSecond(); }
          lastSecondEmit = s;
        }
      }, 250); // chequeo fino; navegadores pueden reducir a >=1s en segundo plano
    }
    function stopBgTicker(){ if (bgTimer) { clearInterval(bgTimer); bgTimer = null; } }

    document.addEventListener('visibilitychange', () => {
      if (document.visibilityState === 'visible') {
        requestWakeLock();
        stopBgTicker();
        lastSecondEmit = -1; // forzar primer tick limpio si vuelve al fondo
        // re-sincronizar visual del anillo y HH:MM al instante
        syncSecondsVisualNow();
        drawTime();
      } else {
        startBgTicker();
      }
    });

    ['click','keydown','touchstart'].forEach(evt => addEventListener(evt, () => { requestWakeLock(); if (ensureAudio()) $audioHint.classList.add('hidden'); }, {passive:true}));

    // Hotkeys: F pantalla completa, S segundero, P 12/24h, M sonido
    addEventListener('keydown', (e)=>{
      const k = e.key;
      if (k === 'f' || k === 'F') { e.preventDefault(); toggleFullscreen(); showControlsTemp(); return; }
      if (k === 's' || k === 'S') { e.preventDefault(); showSeconds = !showSeconds; updateButtons(); savePrefs(); if (showSeconds) syncSecondsVisualNow(); showControlsTemp(); return; }
      if (k === 'p' || k === 'P') { e.preventDefault(); use24h = !use24h; updateButtons(); drawTime(); savePrefs(); showControlsTemp(); return; }
      if (k === 'm' || k === 'M') { e.preventDefault(); soundOn = !soundOn; if (soundOn) { if (!ensureAudio()) $audioHint.classList.remove('hidden'); } else { $audioHint.classList.add('hidden'); } updateButtons(); savePrefs(); showControlsTemp(); return; }
    });

    // Doble click en cualquier lugar (excepto controles): alterna pantalla completa
    addEventListener('dblclick', (e)=>{
      if (e.target.closest('.controls')) return; // no activar si es sobre los botones
      e.preventDefault();
      toggleFullscreen();
      showControlsTemp();
    });

    // Doble toque en mÃ³vil (excepto sobre controles): alterna pantalla completa
    let lastTap = 0, tapX = 0, tapY = 0;
    addEventListener('touchstart', (e)=>{
      const t = e.changedTouches && e.changedTouches[0];
      if (!t) return;
      const now = Date.now();
      const within = now - lastTap < 300;           // ventana para doble toque (~300 ms)
      const dx = Math.abs(t.clientX - tapX);
      const dy = Math.abs(t.clientY - tapY);
      const smallMove = (dx*dx + dy*dy) < (25*25);  // tolerancia ~25px
      const overControls = e.target.closest('.controls');
      if (within && smallMove && !overControls) {
        e.preventDefault();
        toggleFullscreen();
        showControlsTemp();
        lastTap = 0; // reset
      } else {
        lastTap = now; tapX = t.clientX; tapY = t.clientY;
      }
    }, {passive:false});

    // Clicks en botones
    $btnAmPm.addEventListener('click', () => { use24h = !use24h; updateButtons(); drawTime(); savePrefs(); requestWakeLock(); });
    $btnSound.addEventListener('click', () => { soundOn = !soundOn; if (soundOn) { if (!ensureAudio()) $audioHint.classList.remove('hidden'); } else { $audioHint.classList.add('hidden'); } updateButtons(); savePrefs(); requestWakeLock(); });
    $btnSec  .addEventListener('click', () => { showSeconds = !showSeconds; updateButtons(); savePrefs(); requestWakeLock(); if (showSeconds) syncSecondsVisualNow(); });

    // Auto-ocultar controles + cursor sincronizado
    let idleT;
    function showControlsTemp(){
      $controls.classList.remove('hidden');
      document.body.classList.remove('hide-cursor');
      clearTimeout(idleT);
      idleT = setTimeout(() => { $controls.classList.add('hidden'); document.body.classList.add('hide-cursor'); }, HIDE_AFTER);
    }
    ['mousemove','touchstart','click'].forEach(evt => addEventListener(evt, showControlsTemp, {passive:true}));

    /* ==========================================================
       INIT
       ========================================================== */
    (function init(){
      loadPrefs();
      updateButtons();
      drawTime();
      loop();
      requestWakeLock();
      // Intento proactivo de habilitar audio al cargar
      const ok = ensureAudio();
      if (!ok && soundOn) { $audioHint.classList.remove('hidden'); }
      showControlsTemp(); // muestra al entrar y programarÃ¡ su ocultado

      // Si inicia oculto, arranca ticker de fondo
      if (document.hidden) startBgTicker();

      // ====== Sanity checks (no afectan UI) ======
      try {
        console.assert(typeof drawTime === 'function', 'drawTime disponible');
        console.assert(typeof loop === 'function', 'loop disponible');
        console.assert($clock && $btnAmPm && $btnSec && $btnSound, 'DOM listo');
        console.assert(Array.isArray(window.__tickEls) && window.__tickEls.length === 60, 'Ticks (60) generados');
      } catch(_){/* noop */}
    })();
  </script>
</body>
</html>
